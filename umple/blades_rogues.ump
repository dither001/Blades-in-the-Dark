
namespace com.blades.main;

/* */
/* ROGUE */
/* */
class Rogue {
	depend java.util.function.Predicate;
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* vices */
	const FAITH = "faith"; const GAMBLING = "gambling"; const LUXURY = "luxury"; const OBLIGATION = "obligation"; const PLEASURE = "pleasure"; const STUPOR = "stupor"; const WEIRD = "weird";

	/* UNIQUE SET-STREAM */
	const Set<Rogue> SET = new HashSet<Rogue>();	
	after constructor { SET.add(this); } after delete { SET.remove(this); }
	private static Stream<Rogue> getStream() { return SET.stream(); }

	/* */
	lazy UUID id; before getId { if (Util.unless(id)) setId(Util.nextUUID()); } key { id }
	roguename;
	lazy Playbook playbook;
	vice = STUPOR;
	int stress = 0; int trauma = 0; int coin = 0; int stash = 0;
	boolean tapped = false;

	0..1 -> 0..* Aspect aspects;

	/* setup */
	public static void setupRogueShips() {
		int numRogues = (int) Rogue.getRogues().count();

		Rogue[] a = getRogues().toArray(Rogue[]::new);
		for (int i = 1; i < numRogues; i += 2) {
			RogueShip r1 = new RogueShip(a[i], a[(i + 1) % numRogues]);
			r1.setValue(RogueShip.ALLY);
			RogueShip r2 = new RogueShip(a[i], a[(i - 1) % numRogues]);
			r2.setValue(RogueShip.ENEMY);
			new Situation(r1, new Obstacle("Unnamed " + (i-1), "", Aspect.OBSTACLE));
			new Situation(r2, new Obstacle("Unnamed " + i, "", Aspect.OBSTACLE));
		}
	}

	/* instance */
	public List<Rogue> getCircle() { return getRogueShips().stream().map(s -> s.getOther(this)).collect(Collectors.toUnmodifiableList()); }

	public Opportunity lookForWork() {
		Rogue other = getRogueShips().stream().findFirst().get().getOther(this); if (Util.unless(other)) return null;
		Situation sitch = Situation.getSituations(other).filter(s -> Util.unless(s.getShip().contains(this))).findFirst().get(); if (Util.unless(sitch)) return null;
		Crew target = sitch.getShip().getOther(other).getCrew(); if (Util.unless(target)) return null;
		Locale locale = crew.getHuntingGround().stream().findFirst().get(); if (Util.unless(locale)) return null;

		return new Opportunity(target, locale, sitch);
	}

	void doDowntime(int actions) { setTapped(false); }

	/* static */
	public static Stream<Rogue> getRogues() { return getStream(); }
	public static Stream<Rogue> getAvailableRogues() { return getRogues().filter(Predicate.not(Rogue::getTapped)); }
}

/* */
/* ROGUESHIP */
/* */
class RogueShip {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;

	const Predicate<RogueShip> ALLIES = allies();
	const Predicate<RogueShip> CONTACTS = contacts();
	const Predicate<RogueShip> ENEMIES = enemies();
	const Predicate<RogueShip> RIVALS = rivals();

	/* */
	const ALLY = "ally"; const CONTACT = "contact"; const ENEMY = "enemy"; const RIVAL = "rival";

	/* UNIQUE SET-STREAM */
	const Set<RogueShip> SET = new HashSet<RogueShip>();	
	after constructor { SET.add(this); } after delete { SET.remove(this); }
	private static Stream<RogueShip> getStream() { return SET.stream(); }

	/* */
	value = RIVAL;

	* <@>- 2 Rogue rogues;

	key { rogues }

	/* */
	shipname = { String.format("%s + %s", rogues.get(0).getRoguename(), rogues.get(1).getRoguename()) }

	/* */
	boolean contains(Rogue c) { return c.equals(rogues.get(0)) || c.equals(rogues.get(1)); }
	Rogue getOther(Rogue c) { return c.equals(rogues.get(0)) ? rogues.get(1) : c.equals(rogues.get(1)) ? rogues.get(0) : null; }
	
	/* */
	public static Stream<RogueShip> getRogueShips() { return getStream(); }
	public static Stream<RogueShip> getRogueShips(Predicate<RogueShip> predicate) {
		return getRogueShips().filter(ship -> predicate.test(ship));
	}

	/* */
	private static Predicate<RogueShip> allies() { return ship -> { return ship.getValue().matches(ALLY); }; }
	private static Predicate<RogueShip> contacts() { return ship -> { return ship.getValue().matches(CONTACT); }; }
	private static Predicate<RogueShip> enemies() { return ship -> { return ship.getValue().matches(ENEMY); }; }
	private static Predicate<RogueShip> rivals() { return ship -> { return ship.getValue().matches(RIVAL); }; }
}
