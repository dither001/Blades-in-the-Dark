
namespace com.blades.main;

external interface Comparator {}
external interface Runnable {}

/* */
/* ACTIVITY */
/* */
class Activity {
	Objective objective;
	Rogue[] team;
	Aspect[] rules;
	Item[] tools;
	Playbook[] roles;
	CrewShip[] interestedParties;
}

/* */
/* APPROACH */
/* */
class Approach {
	const ASSAULT = "assault"; const DECEPTION = "deception"; const OCCULT = "occult"; const SOCIAL = "social"; const STEALTH = "stealth"; const TRANSPORT = "transport";
}

/* */
/* ENTANGLEMENT */
/* */
class Entanglement {
	const ARREST = "arrest"; const COOPERATION = "cooperation"; const DEMONIC_NOTICE = "demonic notice"; const FLIPPED = "flipped"; const GANG_TROUBLE = "gang trouble"; const INTERROGATION = "interrogation"; const QUESTIONING = "questioning"; const REPRISALS = "reprisals"; const RIVALS = "rivals"; const SHOW_OF_FORCE = "show of force"; const UNQUIET_DEAD = "unquiet dead"; const USUAL_SUSPECTS = "usual suspects";
}

/* */
/* OBJECTIVE */
/* */
class Objective {
	/* real or symbolic value; relevant _physical_ obstacles; exposure -> suitability of target; ; */
	
	Opportunity opportunity;
	/* value; inertia; visibility; accessibility; */
	
	Crew target = { opportunity.getTarget() } 
	Locale locale = { opportunity.getLocale() } 
	Situation situation = { opportunity.getSituation() } 
}

/* */
/* OBSTACLE */
/* */
class Obstacle {
	isA Aspect;

	const SURVEY = "survey";

	name; rating = SURVEY;
	/* Hazards, barriers, and distractions are borrowed from FATE: Accelerated. In short, hazards deal damage, barriers must be opposed, and distractions present choices with consequences. */
	lazy boolean isHazard; lazy boolean isBarrier; lazy boolean isDistraction;
	/* A disctraction consists of the Dilemma, the Effects, and an Opposition value (if any). */
}

/* */
/* OPPORTUNITY */
/* */
class Opportunity {
	depend java.util.Comparator;

	depend java.util.concurrent.PriorityBlockingQueue;
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;
	
	depend com.blades.util.Util;

	/* */
	const Comparator<Opportunity> PRIORITY = priority();
	const PriorityBlockingQueue<Opportunity> QUEUE = new PriorityBlockingQueue<Opportunity>(11, PRIORITY);

	/* UNIQUE SET-STREAM */
	const Set<Opportunity> SET = new HashSet<Opportunity>();	
	after constructor { SET.add(this); } after delete { SET.remove(this); }
	private static Stream<Opportunity> getStream() { return SET.stream(); }

	/* */
	lazy UUID id; before getId { if (Util.unless(id)) setId(Util.nextUUID()); } key { id }
	Crew target;
	Locale locale;
	Situation situation;
	long turnCreated = com.blades.main.GameContext.getInstance().getTurn();

	/* "backdoor" implies alternate plan vector */
	lazy Rogue patron;  lazy Crew[] related; lazy Opportunity[] secrets; lazy String backdoor;
	
	/* */
	after constructor { QUEUE.add(this); }
	
	/* */
	/* */
	/* */
	public static void update() {
		/* FIXME - really, I need a better method of generating opportunities */
		if (QUEUE.size() < 6) {
			Iterator<Crew> crits = Crew.getCrews().iterator();
			Iterator<Locale> pits = Locale.getPlaces().iterator();
			Iterator<Situation> sits = Situation
					.getSituations(RogueShip.getRogueShips(RogueShip.ENEMIES).collect(Collectors.toSet())).iterator();

			while (crits.hasNext() && pits.hasNext() && sits.hasNext()) {
				new Opportunity(crits.next(), pits.next(), sits.next());
			}
		}
	}
	
	/* */
	public static Stream<Opportunity> getOpportunities() { return getStream(); }
	public static Stream<Opportunity> getOpportunities(Crew crew) {
		return getOpportunities().filter(opp -> crew.getTurf().contains(opp.getLocale()));
	}
	
	public static Opportunity next(Crew crew) {
		boolean isTarget = Util.unless(QUEUE.isEmpty()) ? QUEUE.peek().getTarget().equals(crew) : true;
		return Util.unless(isTarget) ? QUEUE.poll() : null;
	}
	
	private static Comparator<Opportunity> priority() { return (op1, op2) -> Long.compare(op2.turnCreated, op1.turnCreated); }
}

/* */
/* PLAN */
/* */
class Plan {
	depend java.util.Arrays;
	depend java.util.List;

	/* */
	Activity activity; approach; Situation detail;
	
	/* */
	List<Rogue> team = { Arrays.asList(activity.getTeam()) }
	List<CrewShip> interestedParties = { Arrays.asList(activity.getInterestedParties()) }
}

/* */
/* SCORE */
/* */
class Score {
	depend java.util.Arrays;
	depend java.util.HashSet;
	depend java.util.List;
	depend java.util.Set;
	depend java.util.UUID;
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* */
	isA Runnable;

	/* UNIQUE SET-STREAM */
	const Set<Score> SET = new HashSet<Score>();	
	after constructor { SET.add(this); } after delete { SET.remove(this); }
	private static Stream<Score> getStream() { return SET.stream(); }

	/* A Score is a short story, composed of "means, motive, and opportunity." Here, the individual meaning of the terms changes to accomodate the game mechanics. */
	lazy UUID id; before getId { if (Util.unless(id)) setId(Util.nextUUID()); } key { id }

	Opportunity opportunity; Plan plan;
	lazy Crew crew; int coin = 6; lazy int heat;
	internal List<Runnable> r = Arrays.asList(this::ready, this::engagement, this::operation, this::payoff, this::heat, this::entanglement, this::downtime);

	/* */
	name = { String.format("The %s job", opportunity.getTarget().getName()) }
	int rep = { 2 - (getCrew().getTier() - opportunity.getTarget().getTier()) }
	Crew target = { getOpportunity().getTarget() }
	boolean undercover = { /* TODO */ false }

	/* boolean accepted = false; boolean abandoned = false; boolean active = false; */
	
	/* */
	List<Rogue> team = { getPlan().getTeam() };
	
	/* */
	@Override void run() { r.stream().forEach(Runnable::run); }
	
	/* */
	public static Stream<Score> getScores() { return getStream(); }
	
	/* score state machine */
	sequence {
		Ready { ready -> /{
			/* */
		} Engagement; }
		Engagement { engagement -> /{
			/* */
			plan.getTeam().forEach(r -> r.setTapped(true));
		} Operation; }
		Operation { operation -> /{
			/* */
		} Payoff; }
		Payoff { payoff -> /{
			/* */
			if (Util.unless(getUndercover())) { getCrew().setRep(getCrew().getRep() + getRep()); }
			/* System.out.println(String.format("%s earned %d rep for %s", getCrew().getName(), getRep(), getName())); */
			getCrew().payoff(this);
			/* System.out.println(String.format("%s earned %d coin for %s", getCrew().getName(), getCoin(), getName())); */
		} Heat; }
		Heat { heat -> /{
			if (getHeat() > 0) { getCrew().setHeat(getCrew().getHeat() + getHeat()); }
			final List<CrewShip> myShips = crew.getCrewShips();
			final Set<CrewShip> parties = getPlan().getInterestedParties().stream()
					.filter(ship -> Util.unless(ship.contains(crew))).collect(Collectors.toUnmodifiableSet());

			parties.stream().forEach(e -> {
				Crew other = e.getOther(getTarget());
				boolean exists = CrewShip.exists(crew, other);
				/* */
				CrewShip ship = exists ? myShips.stream().filter(s -> s.contains(other)).findFirst().get()
						: new CrewShip(0, crew, other);

				if (Util.ensure(ship)) {
					int value = e.hasStatus(CrewShip.ALLIES) ? -1 : e.hasStatus(CrewShip.ENEMIES) ? 1 : 0;
					ship.setValue(ship.getValue() + value);
				}
			});
		} Entanglement; }
		Entanglement { entanglement -> /{
			/* */
		} Downtime; }
		Downtime { downtime -> /{
			/* */
			int actions = (getCrew().getAtWar()) ? 1 : 2;
			plan.getTeam().forEach(r -> r.doDowntime(actions));
			System.out.println(String.format("%s completed the %s job", crew.getName(), opportunity.getTarget().getName()));
			crew.setScore(null);
		} Final; }
	}	
}

/* */
/* SITUATION */
/* */
class Situation {
	depend java.util.HashSet;
	depend java.util.Set;
	depend java.util.stream.Stream;

	/* UNIQUE SET-STREAM */
	const Set<Situation> SET = new HashSet<Situation>();	
	after constructor { SET.add(this); } after delete { SET.remove(this); }
	private static Stream<Situation> getStream() { return SET.stream(); }

	/* */
	RogueShip ship;
	Aspect aspect;
	
	/* static */
	public static Stream<Situation> getSituations() { return getStream(); }
	public static Stream<Situation> getSituations(Rogue rogue) { return getSituations().filter(s -> s.getShip().contains(rogue)); }
	public static Stream<Situation> getSituations(RogueShip ship) { return getSituations().filter(s -> s.getShip().equals(ship)); }
	public static Stream<Situation> getSituations(Set<RogueShip> set) { return getSituations().filter(e -> set.contains(e.getShip())); }
}
