
namespace com;

external interface Runnable {}

/* */
class Society {
  Crew[] institutions;

  0..1 -> 1 Heritage;
  0..1 -> 1 Locale territory;
  0..1 -- * Crew groups sorted {name};
  0..1 -- * Rogue members sorted {status};
  
  Ladder ladder = { territory.getLadder() }
  
  void institutionalize(Crew crew) { institutions.add(crew); }
  void socialize(Rogue rogue) {}
}

/* */
class Ladder {
  0..1 -- * Crew crews sorted {tier};
}

class Locale {
  lazy int wealth; lazy int security; lazy int crime; lazy int occult;

  1 -- 1 Ladder;
  0..1 parent -- 0..* Locale children;
}

associationClass Claim {
  boolean isHuntingGround = false; boolean isLair = false; 
  boolean isPrison = false; boolean isTurf = false;
  0..* Crew;
  0..* Locale;
  0..1 -- * Zoning;
}

/* */
class Scope {
	Type { Personal, Local, Regional, Global, Planar, Cosmic }
}

class Zoning {
	Type { Purpose, Rulespace, Professional, Personal } 
}

/* */
class Crew {
  name;
  Integer tier = 0; int rep = 0; int coin = 2; 
  int heat = 0; int wanted = 0;

  0..* -- 1 CrewPlaybook playbook;
  0..1 patron -- 0..* Crew vassals;
}

class Reputation {
  Type { Ambitious, Brutal, Daring, Honorable, Professional, Savvy, Subtle, Strange }
  int value;
  * -- 2 Crew crews;
  key { crews }
	
  boolean atWar = { value < -2 }
  boolean allies = { value > 1 }
  boolean enemies = { value < -1 }
  boolean rivals = { value > -2 && value < 2 }
}

class CrewPlaybook {
  Type { Assassins, Bravos, Cultists, Hawkers, Shadows, Smugglers }
}

/* */
class Rogue {
  const int LIGHT_LOAD = 3; const int MEDIUM_LOAD = 5; const int HEAVY_LOAD = 6;

  /* */
  name; int load = LIGHT_LOAD;
  
  0..* -- 1 RoguePlaybook playbook;
  
  
  int publicity = 0;
  int fame = { Math.abs(publicity) }
  
  int knowledge = 0;
  int power = { knowledge }

  int coin = 0; int stash = 0;
  int wealth = { coin + stash }
  Double status = { Math.cbrt(wealth*wealth + fame*fame + power*power) }
}

class Relationship {
  Type { Ally, Contact, Enemy, Rival }
  0..* -- 0..1 Background;
  0..* -- 0..1 Heritage;
  0..* -- 0..1 Vice;
  int trust = 2; int intimacy = 2; int stress = 0;
  boolean isFamily = false; 
  boolean isFriends = false; 
  boolean isLovers = false;

  * -- 2 Rogue rogues;
  key { rogues }
  
  boolean broken = { trust < 1 }
}

class RoguePlaybook {
  Type { Cutter, Hound, Leech, Lurk, Slide, Spider, Whisper }
}

class Background {
  Type { Academic, Labor, Law, Trade, Military, Noble, Underworld }
}

class Heritage {
  Type { Akoros, DaggerIsles, Iruvia, Severos, Skovlan, Tycheros }
}

class Vice {
  Type { Faith, Gambling, Luxury, Obligation, Pleasure, Stupor, Weird }
}

/* */
associationClass CrewMember {
  0..* Crew;
  0..* Rogue;
}

/* */
class Score {
  isA Runnable;
}

class Opportunity {
  0..* -- 1 Crew target;
  0..* -- 1 Locale;
  0..* -- 1 Situation;
}

class Scenario {
  /* "that which is pinned to scenery" */
  0..* -- 1 Asset;
  0..* -- 1 Claim;
}

associationClass Situation {
  0..* Obstacle;
  0..* Relationship;
  0..* Scenario;
}

class Activity {
  /* objective */
  /* rules-constraints */
  Item[] tools;
  RoguePlaybook[] roles;
}

class Obstacle {
  /* Hazards, barriers, and distractions are borrowed from FATE: Accelerated. In short, hazards deal damage, barriers must be opposed, and distractions present choices with consequences. */
  Type { Barrier, Distraction, Hazard }
  /* A distraction consists of the Dilemma, the Effects, and an Opposition value (if any). */

  name;
}

class Plan {
  Type { Assault, Deception, Occult, Social, Stealth, Transport }
  
  Rogue[] team;
  Reputation[] interestedParties;
  0..* -- 1 Rogue mastermind;
}

class Asset {
  Type { Coin, Food, Labor, Goods, Item, Favor, Magic, Claim }
  name; int load; int quantity = 1;
}