strictness allow 46;
strictness allow 1007;
strictness allow 1008;

use goap.ump;
use util.ump;

namespace com.blades.main;

/* */
/* CLAIM */
/* */
class Claim {
	unique UUID id;
	Crew crew;
	Locale locale;
	name; type;
	boolean isPrison;
	
	key { id }
}

/* */
/* CREW */
/* */
class Crew {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	depend com.blades.util.Util;

	/* */
	const AMBITIOUS = "ambitious"; // TODO
	/* */
	const ASSASSINS = "assassins"; const BRAVOS = "bravos"; const CULTISTS = "cultists"; const HAWKERS = "hawkers"; const SHADOWS = "shadows"; const SMUGGLERS = "smugglers";

	/* */
	unique UUID id;
	name; type; 
	favoredOp;
	String[] reputation;
	Locale huntingGrounds; Locale lair;
	int rep; int tier; int heat; int wanted; int coin;
	boolean hold;
	Rogue[] rogues; Claim[] claims; Score[] scores;
	/* Opportunity[] opportunities; */

	key { id }
	
	/* calculated fields */
	boolean atWar = { CrewShip.atWar(this) }
	boolean lookingForWork = { ! (scores.stream().anyMatch(Score::getActive)) };

	/** Primary means for determining crew's hold.
	* @return boolean modified by whether crew is at war. */
	boolean currentHold = { getAtWar() ? hold ? false : hold : hold }

	/** Primary means for determining crew's tier. 
	* @return int modified by whether crew is at war and has strong/weak hold. */
	int currentRep = { getAtWar() ? hold ? rep : rep - 1 : rep }
	
	/* instance */
	public Stream<Rogue> getRoster() { return rogues.stream(); }
	public Stream<Rogue> getAvailableRogues() {
		return rogues.stream().filter(Predicate.not(Rogue::getTapped));
	}
	
	public void lookForWork() {
		/* getAvailableRogues().map(Rogue::seekOpportunity).forEach(opportunities::add); */
	}
	
	boolean acceptWork(Score score) {
		boolean accepted = false;
		// TODO
		if (getRoster().count() > 0) { accepted = scores.add(score); }
		return accepted;
	}
	
	List<Rogue> selectTeam(Score score) {
		// TODO
		return List.copyOf(rogues);
	}
	
	/* static */
	public static Crew getCrewByName(String name) {
		return getCrews().filter(s -> s.getName().equalsIgnoreCase(name)).findFirst().get();
	}

	public static Crew newFaction(UUID aId, String aName, int aTier, boolean aHold) {
		return new Crew(aId, aName, null, null, null, null, 0, aTier, 0, 0, 2, aHold);
	}

	public static Crew newCrew(UUID aId, String aName, String aType, String aFavoredOp, Locale aHuntingGrounds, Locale aLair, int aRep, int aTier, int aHeat, int aWanted, int aCoin, boolean aHold) {
		return new Crew(aId, aName, aType, aFavoredOp, aHuntingGrounds, aLair, 0, 0, 0, 0, 2, true);
	}

	/* */
	public static Stream<Crew> getCrews() { return crewsById.values().stream(); };
	public static Stream<Crew> getCrewsLookingForWork() { return getCrews().filter(Crew::getLookingForWork); }
	public static void update() {
		/* TODO */
		getCrewsLookingForWork().forEach(Crew::lookForWork);
	}
}

/* */
/* ENTANGLEMENT */
/* */
class Entanglement {
	const ARREST = "arrest"; const COOPERATION = "cooperation"; const DEMONIC_NOTICE = "demonic notice"; const FLIPPED = "flipped"; const GANG_TROUBLE = "gang trouble"; const INTERROGATION = "interrogation"; const QUESTIONING = "questioning"; const REPRISALS = "reprisals"; const RIVALS = "rivals"; const SHOW_OF_FORCE = "show of force"; const UNQUIET_DEAD = "unquiet dead"; const USUAL_SUSPECTS = "usual suspects";
}

/* */
/* GAME CONTEXT */
/* */
class GameContext {
	singleton;
}

/* */
/* GAME LOOP */
/* */
class GameLoop {
	singleton;
	
	/* */
	boolean running = true;

	/* instance */
	void loop() { while (running) { update(); } }
	void update() { Crew.update(); }
	
	/* static */
	public static void main(String...args) {
		com.blades.util.Loader.getInstance();
		/* GameLoop.getInstance().loop(); */
	}
	
	/* game state machine */
	sequence {
		Untap { untap() -> Upkeep; }
		Upkeep { upkeep() -> Draw; }
		Draw { draw() -> Main; }
		Main { main() -> Combat; }
		Combat { combat() -> Main2; }
		Main2 { main2() -> Cleanup; }
		Cleanup { cleanup() -> Untap; }
	}
}

/* */
/* LOCALE */
/* */
class Locale {
	depend java.util.stream.Stream;

	/* */
	const BARROWCLEFT = "Barrowcleft"; const BRIGHTSTONE = "Brightstone"; 
	const CHARHOLLOW = "Charhollow"; const CHARTERHALL = "Charterhall"; 
	const COALRIDGE = "Coalridge"; const CROWS_FOOT = "Crow's Foot";
	const THE_DOCKS = "The Docks"; const DUNSLOUGH = "Dunslough"; 
	const NIGHTMARKET = "Nightmarket"; const SILKSHORE = "Silkshore"; 
	const SIX_TOWERS = "Six Towers"; const WHITECROWN = "Whitecrown";
	
	/* */
	unique UUID id;
	name;
	Crew boss;
	immutable Locale district;
	immutable Claim claim;
	boolean isClaim = { claim != null }
	boolean isDistrict = { district == null }
	
	key { id }
	
	/* */
	public static Stream<Locale> getLocales() { return localesById.values().stream(); }
}

/* */
/* OBSTACLE */
/* */
class Obstacle {}

/* */
/* PLAN */
/* */
class Plan {
	depend com.blades.goap.Goal;

	const ASSAULT = "assault"; const DECEPTION = "deception"; const OCCULT = "occult"; const SOCIAL = "social"; const STEALTH = "stealth"; const TRANSPORT = "transport";
	/* */
	const ACCIDENT = "accident"; // TODO

	/* */
	Crew crew; Goal goal;
	Rogue[] team;
	approach; activity; detail;
}

/* */
/* ROGUE */
/* */
class Rogue {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	depend com.blades.goap.Goal;
	depend com.blades.util.Util;

	/* vices */
	const FAITH = "faith"; const GAMBLING = "gambling"; const LUXURY = "luxury"; const OBLIGATION = "obligation"; const PLEASURE = "pleasure"; const STUPOR = "stupor"; const WEIRD = "weird";
	/* playbooks */
	const CUTTER = "cutter"; const HOUND = "hound"; const LEECH = "leech"; const LURK = "lurk"; const SLIDE = "slide"; const SPIDER = "spider"; const WHISPER = "whisper";

	/* */
	unique UUID id;
	Crew crew;
	Goal[] goals;
	roguename; playbook; vice;
	int stress; int trauma; int coin; int stash;
	boolean tapped = false;

	key { id }
	
	/* instance */
	void doDowntime(int actions) { setTapped(false); }
	
	/* static */
	public static Rogue newContact(UUID aid, String aRoguename) {
		return new Rogue(aid, null, aRoguename, null, null, 0, 0, 0, 0);
	}

	public static Rogue newRogue(UUID aId, Crew aCrew, aRoguename, aPlaybook, aVice) {
		return new Rogue(aId, aCrew, aRoguename, aPlaybook, aVice, 0, 0, 0, 0);
	}
	
	public static Stream<Rogue> getRogues() { return roguesById.values().stream(); }

	public static Stream<Rogue> getAvailableRogues() { return getRogues().filter(Predicate.not(Rogue::getTapped)); }
	public static Stream<Rogue> getRoguesWithGoals() { return getRogues().filter(Rogue::hasGoals); }
	public static Stream<Goal> getRogueGoals() { return getRoguesWithGoals().map(Rogue::getGoals).flatMap(Arrays::stream); }
}

/* */
/* SCORE */
/* */
class Score {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	depend com.blades.goap.Goal;

	/* */
	unique UUID id;
	Opportunity opportunity; Plan plan;	
	lazy Obstacle[] obstacles;
	int coin; int heat;

	name = { String.format("The %s %s", opportunity.getTarget().getName(), plan.getActivity()) };
	int rep = { 2 - (plan.getCrew().getTier() - opportunity.getTarget().getTier()) };
	boolean accepted = false; boolean abandoned = false; boolean active = false;

	key { id }
	
	/* score state machine */
	sequence {
		Ready { doReady -> Engagement; }
		Engagement { 
			doEngagement -> /{
				Stream.of(plan.getTeam()).forEach(r -> { r.setTapped(true); });
			} Operation; 
		}
		Operation { doOperation -> Payoff; }
		Payoff { doPayoff -> Heat; }
		Heat { doHeat -> Entanglement; }
		Entanglement { doEntanglement -> Downtime; }
		Downtime { 
			doDowntime -> /{
				int actions = (plan.getCrew().getAtWar()) ? 1 : 2;
				Stream.of(plan.getTeam()).forEach(r -> r.doDowntime(actions));
			} Final;
		}
	}
	
	/* static */
	public static Score newScore(UUID aId, Opportunity aOpportunity, Plan aPlan) {
		return new Score(aId, aOpportunity, aPlan, 0, 0);
	}
	
	/* */
	public static Stream<Score> getScores() { return scoresById.values().stream(); }
	public static Stream<Score> getAvailableScores() { return getScores().filter(Predicate.not(Score::getAccepted)); }
}

/* */
/* SITUATION */
/* */
class Situation {
	depend com.blades.goap.State;

	unique UUID id;
	State[] effects;
	
	key { id }
	
	/* */
	public static Situation newSituation(UUID aId) { return new Situation(aId); }
}

/* */
/* CREWSHIP */
/* */
associationClass CrewShip {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	/* */
	const Predicate<CrewShip> ALLIES = allies();
	const Predicate<CrewShip> ENEMIES = enemies();
	const Predicate<CrewShip> RIVALS = rivals();
	const Predicate<CrewShip> AT_WAR = at_war();

	/* */
	unique UUID id;
	* Crew a -> * Crew b;
	int value;

	key { a, b }

	/* */
	boolean contains(Crew c) { return a.equals(c) || b.equals(c); }
	Crew getOther(Crew c) { return c.equals(a) ? b : c.equals(b) ? a : null; }

	/* */
	public static Stream<CrewShip> getShips() { return crewshipsById.values().stream(); }
	public static Stream<CrewShip> getShips(Crew crew) { return getShips().filter(c -> c.contains(crew)); }
	public static boolean atWar(Crew crew) { return getShips(crew).anyMatch(AT_WAR); }

	/* */
	private static Predicate<CrewShip> allies() { return ship -> { return ship.getValue() > 1; }; }
	private static Predicate<CrewShip> enemies() { return ship -> { return ship.getValue() < -1; }; }
	private static Predicate<CrewShip> rivals() { return ship -> { return ship.getValue() > -2 && ship.getValue() < 2; }; }
	private static Predicate<CrewShip> at_war() { return ship -> { return ship.getValue() < -2; }; }
}

/* */
/* OPPORTUNITY */
/* */
associationClass Opportunity {
	depend java.util.stream.Stream;

	lazy Rogue patron; 
	* Crew target;
	* Locale locale;
	* Situation situation;
	
	/* */
	lazy Crew[] related;
	/* "backdoor" implies alternate plan vector */
	lazy String backdoor;
	lazy Opportunity[] secrets;
	
	key { target, locale }

	/* instance */
	String gatherInformation(Rogue rogue) {
		/* Rogue.getRoguesWithGoals().filter(Predicate.not(Rogue::getTapped)).map(Rogue::offerJob); */
		return "detail";
	};
}

/* */
/* ROGUESHIP */
/* */
associationClass RogueShip {
	/* */
	unique Integer id;

	const ALLY = "ally"; const CONTACT = "contact"; const ENEMY = "enemy"; const RIVAL = "rival";

	/* */
	1 Rogue a -> 1 Rogue b;
	value = ALLY;
	key { a, b }

	/* */
	boolean contains(Rogue c) { return a.equals(c) || b.equals(c); }
	Rogue getOther(Rogue c) { return c.equals(a) ? b : c.equals(b) ? a : null; }
}
