strictness allow 46;
strictness allow 1007;
strictness allow 1008;

use blades_crews.ump;
use blades_rogues.ump;
use blades_scores.ump;
use goap.ump;
use util.ump;

namespace com.blades.main;

/* */
/* CLAIM */
/* */
class Claim {
	unique UUID id;
	Crew crew;
	Locale locale;
	name; type;
	boolean isPrison;
	
	key { id }
}

/* */
/* GAME CONTEXT */
/* */
class GameContext {
	singleton;
	
	long turn = 0L;
}

/* */
/* GAME LOOP */
/* */
class GameLoop {
	singleton;
	
	depend java.util.List;
	depend java.util.stream.Collectors;
	
	depend com.blades.util.Util;
	
	/* */
	GameContext context = com.blades.main.GameContext.getInstance();
	GameLoop g = GameLoop.getInstance();
	List<Runnable> r = Arrays.asList(g::untap, g::upkeep, g::draw, g::main, g::combat, g::main2, g::cleanup);
	
	boolean running = true;
	
	/* instance */
	void loop() { while (running) { update(); } }
	void update() { Crew.update(); }
	
	/* static */
	public static void main(String...args) {
		com.blades.util.Loader.getInstance();

		/* */		
		g.testRogueships();
		
		Crew.update();
	}
	
	private static void testScore() {
		Situation sitch = Situation.getSituations().filter(s -> {
			return Util.ensure(s.getShip().getRogue(0).getCrew().getLair());
		}).findFirst().get();
		System.out.println(sitch.getShip().getShipname());

		Crew target = sitch.getShip().getRogue(0).getCrew();
		System.out.println(target.getName());

		Locale locale = target.getLair();
		System.out.println(locale.getName());

		Opportunity opp = new Opportunity(Util.nextUUID(), target, locale, sitch);
	}
	
	private static void testRogueships() {
		int numCrews = (int) Crew.getCrews().count();
		List<Crew> crews = Crew.getCrews().collect(Collectors.toUnmodifiableList());

		Rogue[] a = new Rogue[125];
		a[0] = new Rogue(Util.nextUUID(), "Unnamed rogue 0", null, null, crews.get(0));
		for (int i = 1; i < 125; ++i) {
			Crew c = crews.get(i % numCrews);
//			System.out.println(c.getName());

			a[i] = new Rogue(Util.nextUUID(), "Unnamed rogue " + i, null, null, c);
			new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[i], a[i - 1]),
					new Obstacle("Unnamed " + i));

			c.addRogue(a[i]);
//			System.out.println(crews.get(i % numCrews).getName());
		}
		new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[0], a[124]), new Obstacle("Unnamed 0"));

		System.out.println("Total Rogues: " + Rogue.getRogues().count());
		System.out.println("Total 'ships: " + RogueShip.getRogueships().count());
		System.out.println("Total Crews: " + Crew.getCrews().count());
//		Crew.getCrews().forEach(c -> System.out.println(c.numberOfRogues()));
//		CrewShip.getShips().forEach(ship -> System.out.println(String.format("%s %s", ship.getValue(), ship.getGetshipname())));

//		RogueShip.getRogueships().forEach(ship -> System.out.println(ship.getSituation(0).getObstacle().getName()));	   
//		Crew.getCrews().forEach(crew -> System.out.println(crew.getName()));
	}
	
	/* game state machine */
	sequence {
		Untap { untap() -> /{
		} Upkeep; }
		Upkeep { upkeep() -> /{
			Opportunity.update();
		} Draw; }
		Draw { draw() -> /{
			Crew.update();
		} Main; }
		Main { main() -> /{
		} Combat; }
		Combat { combat() /{} -> Main2; }
		Main2 { main2() -> /{} Cleanup; }
		Cleanup { cleanup() -> /{
			context.setTurn(context.getTurn() + 1);
		} Untap; }
	}
}

/* */
/* ITEM */
/* */
class Item {}

/* */
/* LOCALE */
/* */
class Locale {
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* */
	public static final List<String> COMMON_BUILDINGS = new ArrayList<String>();
	public static final List<String> UNCOMMON_BUILDINGS = new ArrayList<String>();

	/* */
	unique UUID id;
	name;
	
	/* */
	lazy int wealth; lazy int security; lazy int crime; lazy int occult; 
	lazy boolean isLair; lazy boolean isHuntingGround; lazy boolean isTurf;
	lazy Zoning zoning;

	key { id }
	
	0..1 parent -- * Locale children;
	
	boolean isDistrict = { Util.unless(getHasZoning()) }
	boolean isNeighborhood = { name.matches("neighborhood") }
	boolean hasZoning = { zoning != null }

	/* */
	public static Stream<Locale> getLocales() { return localesById.values().stream(); }
	public static Stream<Locale> getPlaces() { return getLocales().filter(Locale::hasParent); }
	public static Locale getLocaleByName(String name) {
		return getLocales().filter(l -> l.getName().matches(name)).findFirst().get();
	}
}

/* */
/* PLAYBOOK */
/* */
class Playbook {
	/* playbooks */
	const CUTTER = "cutter"; const HOUND = "hound"; const LEECH = "leech"; const LURK = "lurk"; const SLIDE = "slide"; const SPIDER = "spider"; const WHISPER = "whisper";
	
	/* */
	name = CUTTER;
}

/* */
/* ZONING */
/* */
class Zoning {
	/* work, play, movement, waiting, rest */
	const PURPOSE = "purpose"; const RULESPACE = "rulespace"; const PROFESSIONAL = "professional"; const PERSONAL = "personal";

	/* */
	type;

	/* instance */
	boolean isPublic = { type.matches(PURPOSE) || type.matches(RULESPACE) }
	boolean isPrivate = { type.matches(PROFESSIONAL) || type.matches(PERSONAL) }
}
