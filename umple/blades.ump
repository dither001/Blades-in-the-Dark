strictness allow 46;
strictness allow 1007;
strictness allow 1008;

use blades_crews.ump;
use blades_rogues.ump;
use blades_scores.ump;
use goap.ump;
use util.ump;

namespace com.blades.main;

/* */
/* CLAIM */
/* */
class Claim {
	unique UUID id;
	Crew crew;
	Locale locale;
	name; type;
	boolean isPrison;
	
	key { id }
}

/* */
/* GAME CONTEXT */
/* */
class GameContext {
	singleton;
	
	long turn = 0L;
}

/* */
/* GAME LOOP */
/* */
class GameLoop {
	singleton;
	
	depend java.util.Arrays;
	depend java.util.List;
	depend java.util.stream.Collectors;
	
	depend com.blades.util.Util;
	
	/* */
	GameContext context = com.blades.main.GameContext.getInstance();
	internal List<Runnable> r = Arrays.asList(this::untap, this::upkeep, this::draw, this::main, this::combat, this::main2, this::cleanup);

	/* static */
	public static void main(String...args) {

		/* */
		com.blades.util.Loader.getInstance();
		GameLoop.testRogueships();
		Crew.initialize();
		/* */
		while (true) {
			GameLoop.getInstance().r.stream().forEach(Runnable::run);
		}
		
		/* Rogue.getAvailableRogues().forEach(rogue -> { Rogue rog = rogue.getRogueShips().stream().filter(RogueShip.RIVALS).findFirst().orElse(null).getOther(rogue); });*/ 
	}
	
	private static void testScore() {
		Situation sitch = Situation.getSituations().filter(s -> {
			return Util.ensure(s.getShip().getRogue(0).getCrew().getLair());
		}).findFirst().get();
		System.out.println(sitch.getShip().getShipname());

		Crew target = sitch.getShip().getRogue(0).getCrew();
		System.out.println(target.getName());

		Locale locale = target.getLair();
		System.out.println(locale.getName());

		Opportunity opp = new Opportunity(Util.nextUUID(), target, locale, sitch);
	}
	
	private static void testRogueships() {
		int numCrews = (int) Crew.getCrews().count();
		List<Crew> crews = Crew.getCrews().collect(Collectors.toUnmodifiableList());

		Rogue[] a = new Rogue[125];
		a[0] = new Rogue(Util.nextUUID(), "Unnamed rogue 0", null, null, crews.get(0));
		for (int i = 1; i < 125; ++i) {
			Crew c = crews.get(i % numCrews);
//			System.out.println(c.getName());

			a[i] = new Rogue(Util.nextUUID(), "Unnamed rogue " + i, null, null, c);
			new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[i], a[i - 1]),
					new Obstacle("Unnamed " + i));

			c.addRogue(a[i]);
//			System.out.println(crews.get(i % numCrews).getName());
		}
		new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[0], a[124]), new Obstacle("Unnamed 0"));

		System.out.println("Total Rogues: " + Rogue.getRogues().count());
		System.out.println("Total 'ships: " + RogueShip.getRogueships().count());
		System.out.println("Total Crews: " + Crew.getCrews().count());
//		Crew.getCrews().forEach(c -> System.out.println(c.numberOfRogues()));
//		CrewShip.getShips().forEach(ship -> System.out.println(String.format("%s %s", ship.getValue(), ship.getGetshipname())));

//		RogueShip.getRogueships().forEach(ship -> System.out.println(ship.getSituation(0).getObstacle().getName()));	   
//		Crew.getCrews().forEach(crew -> System.out.println(crew.getName()));
	}
	
	/* */
	/* GAME STATE MACHINE */
	/* */
	before setSequence { 
		System.out.println("--> Began phase: " + aSequence.name()); 
	}
	
	/* game state machine */
	sequence {
		Untap { untap -> /{ 
			System.out.println(String.format("Started turn %d", context.getTurn())); 
		} Upkeep; } 
		Upkeep { upkeep -> /{ 
			Opportunity.update(); 
		} Draw; } 
		Draw { draw -> /{ 
			Crew.update(); 
		} Main; } 
		Main { main -> /{ 
			Crew.getCrewsWithScores().limit(6).forEach(c -> c.getScore().run());
		} Combat; } 
		Combat { combat -> /{
		} Main2; } 
		Main2 { main2 -> /{
		} Cleanup; } 
		Cleanup { cleanup -> /{ 
			context.setTurn(context.getTurn() + 1); 
		} Untap; }
	}
	
	
}

/* */
/* ITEM */
/* */
class Item {}

/* */
/* LOCALE */
/* */
class Locale {
	depend java.util.stream.Stream;
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* */
	public static final List<String> COMMON_BUILDINGS = Collections.synchronizedList(new ArrayList<String>());
	public static final List<String> UNCOMMON_BUILDINGS = Collections.synchronizedList(new ArrayList<String>());
	public static final List<Locale> DISTRICTS = Collections.synchronizedList(new ArrayList<Locale>());

	/* */
	unique UUID id;
	name;
	
	/* */
	lazy int wealth; lazy int security; lazy int crime; lazy int occult;
	boolean isDistrict = false; boolean isNeighborhood = false;
	boolean isLair = false; boolean isHuntingGround = false; boolean isTurf = false;
	lazy Zoning zoning;

	key { id }
	
	0..1 parent -- * Locale children;
	
	boolean hasZoning = { zoning != null }

	/* */
	public static Stream<Locale> getLocales() { return localesById.values().stream(); }
	public static Stream<Locale> getDistricts() { return getLocales().filter(Locale::getIsDistrict); }
	public static Stream<Locale> getPlaces() { return getLocales().filter(Locale::hasParent); }
	public static Locale getLocaleByName(String name) {
		return getLocales().filter(l -> l.getName().matches(name)).findFirst().get();
	}
	
	public static synchronized String nextCommonBuilding() { String l = COMMON_BUILDINGS.remove(0); COMMON_BUILDINGS.add(l); return l; }
	public static synchronized String nextUncommonBuilding() { String l = UNCOMMON_BUILDINGS.remove(0); UNCOMMON_BUILDINGS.add(l); return l; }
	public static synchronized Locale nextDistrict() { Locale l = DISTRICTS.remove(0); DISTRICTS.add(l); return l; }
}

/* */
/* PLAYBOOK */
/* */
class Playbook {
	/* playbooks */
	const CUTTER = "cutter"; const HOUND = "hound"; const LEECH = "leech"; const LURK = "lurk"; const SLIDE = "slide"; const SPIDER = "spider"; const WHISPER = "whisper";
	
	/* */
	name = CUTTER;
}

/* */
/* ZONING */
/* */
class Zoning {
	/* work, play, movement, waiting, rest */
	const PURPOSE = "purpose"; const RULESPACE = "rulespace"; const PROFESSIONAL = "professional"; const PERSONAL = "personal";

	/* */
	type;

	/* instance */
	boolean isPublic = { type.matches(PURPOSE) || type.matches(RULESPACE) }
	boolean isPrivate = { type.matches(PROFESSIONAL) || type.matches(PERSONAL) }
}
