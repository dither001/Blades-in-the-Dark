strictness allow 46;
strictness allow 1007;
strictness allow 1008;

use blades_crews.ump;
use blades_rogues.ump;
use blades_scores.ump;
use goap.ump;
use util.ump;

external interface Comparable {}

namespace com.blades.main;

/* */
/* ASPECT */
/* */
class Aspect {
	depend java.util.ArrayList;
	depend java.util.Collections;
	depend java.util.List;
	depend java.util.function.Predicate;
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;
	
	/* */
	isA Comparable;

	/* */
	const CONTACT = "contact"; const EXPERT = "expert"; const GANG = "gang"; 
	const PLAYBOOK = "playbook"; const REPUTATION = "reputation"; const UPGRADE = "upgrade";
	/* */
	const HOOK = "hook"; const OBSTACLE = "obstacle";

	/* */
	public static final List<Aspect> ASPECTS = Collections.synchronizedList(new ArrayList<Aspect>());

	after constructor { ASPECTS.add(this); }
	after delete { ASPECTS.remove(this); }

	/* */
	name; description; type;

	key { name, type }
	
	/* */
	@Override public int compareTo(Aspect o) { return name.compareTo(o.name); }
	
	/* */
	public static List<Aspect> getContacts() { return get(a -> a.type.matches(CONTACT)).collect(Collectors.toUnmodifiableList()); }
	public static List<Aspect> getReputations() { return get(a -> a.type.matches(REPUTATION)).collect(Collectors.toUnmodifiableList()); }
	public static List<Aspect> getUpgrades() { return get(a -> a.type.matches(UPGRADE)).collect(Collectors.toUnmodifiableList()); }
	
	public static Stream<Aspect> get(Predicate<Aspect> predicate) { return ASPECTS.stream().filter(a -> predicate.test(a)); }
}

/* */
/* CREW-ROGUE SHIP */
/* */
associationClass CrewRogueShip {
	value;

	* Crew;
	* Rogue;
}

/* */
/* GAME CONTEXT */
/* */
class GameContext {
	singleton;
	
	long turn = 0L;
}

/* */
/* GAME LOOP */
/* */
class GameLoop {
	singleton;
	
	depend java.util.Arrays;
	depend java.util.List;
	depend java.util.stream.Collectors;
	
	depend com.blades.util.Util;
	
	/* */
	GameContext context = com.blades.main.GameContext.getInstance();
	internal List<Runnable> r = Arrays.asList(this::untap, this::upkeep, this::draw, this::main, this::combat, this::main2, this::cleanup);

	/* static */
	public static void main(String...args) {

		/* */
		GameLoop.initialize();
		
		/* */
		while (true) { GameLoop.getInstance().r.stream().forEach(Runnable::run); }		
	}
	
	/* */
	private static void initialize() {
		com.blades.util.Loader.getInstance();
		GameLoop.testRogueships();
		Crew.initialize();
		Ladder.initialize();
	}
	
	private static void testLadders() {
		Locale.getDistricts().map(d -> Ladder.getWithDistrict(d)).forEach(e -> {
			System.out.println(String.format("%s (%d : %s [%d]): %s", 
					e.getDistrict().getName(), 
					e.getBoss().getTier(), 
					e.getBoss().getName(), 
					e.getBoss().numberOfCrewShips(), 
					e.getCrews().stream().map(Crew::getName).collect(Collectors.toUnmodifiableList())));
		});
	}
	
	private static void testScore() {
		Situation sitch = Situation.getSituations().filter(s -> {
			return Util.ensure(s.getShip().getRogue(0).getCrew().getLair());
		}).findFirst().get();
		System.out.println(sitch.getShip().getShipname());

		Crew target = sitch.getShip().getRogue(0).getCrew();
		System.out.println(target.getName());

		Locale locale = target.getLair();
		System.out.println(locale.getName());

		Opportunity opp = new Opportunity(Util.nextUUID(), target, locale, sitch);
	}
	
	private static void testRogueships() {
		int numCrews = (int) Crew.getCrews().count();
		List<Crew> crews = Crew.getCrews().collect(Collectors.toUnmodifiableList());

		Rogue[] a = new Rogue[125];
		a[0] = new Rogue(Util.nextUUID(), "Unnamed rogue 0", null, null, crews.get(0));
		for (int i = 1; i < 125; ++i) {
			Crew c = crews.get(i % numCrews);
//			System.out.println(c.getName());

			a[i] = new Rogue(Util.nextUUID(), "Unnamed rogue " + i, null, null, c);
			new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[i], a[i - 1]),
					new Obstacle("Unnamed " + i, "", Aspect.OBSTACLE));

			c.addRogue(a[i]);
//			System.out.println(crews.get(i % numCrews).getName());
		}
		new Situation(Util.nextUUID(), new RogueShip(Util.nextUUID(), a[0], a[124]), new Obstacle("Unnamed 0", "", Aspect.OBSTACLE));

		System.out.println("Total Rogues: " + Rogue.getRogues().count());
		System.out.println("Total 'ships: " + RogueShip.getRogueships().count());
		System.out.println("Total Crews: " + Crew.getCrews().count());
//		Crew.getCrews().forEach(c -> System.out.println(c.numberOfRogues()));
//		CrewShip.getShips().forEach(ship -> System.out.println(String.format("%s %s", ship.getValue(), ship.getGetshipname())));

//		RogueShip.getRogueships().forEach(ship -> System.out.println(ship.getSituation(0).getObstacle().getName()));	   
//		Crew.getCrews().forEach(crew -> System.out.println(crew.getName()));
	}
	
	/* */
	/* GAME STATE MACHINE */
	/* */
	before setSequence { 
		System.out.println("--> Began phase: " + aSequence.name()); 
	}
	
	/* game state machine */
	sequence {
		Untap { untap -> /{ 
			System.out.println(String.format("Started turn %d", context.getTurn())); 
		} Upkeep; } 
		Upkeep { upkeep -> /{ 
			Opportunity.update(); 
		} Draw; } 
		Draw { draw -> /{ 
			Crew.update(); 
		} Main; } 
		Main { main -> /{ 
			Crew.getCrewsWithScores().limit(6).forEach(c -> c.getScore().run());
		} Combat; } 
		Combat { combat -> /{
		} Main2; } 
		Main2 { main2 -> /{
		} Cleanup; } 
		Cleanup { cleanup -> /{ 
			context.setTurn(context.getTurn() + 1); 
		} Untap; }
	}
	
	
}

/* */
/* ITEM */
/* */
class Item {}

/* */
/* LADDER */
/* */
class Ladder {
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;
	
	depend com.blades.util.Util;

	/* */
	0..1 -- 0..* Crew;

	/* */
	unique Locale district; 
	Crew boss;

	key { district }

	/* */
	public static void initialize() { 
		Locale.getDistricts().forEach(e -> laddersByDistrict.put(e, new Ladder(e, null)));

		Crew.getCrews().flatMap(c -> c.getHuntingGround().stream())
				.forEach(g -> Ladder.getWithDistrict(g.getParent()).addCrew(g.getCrew()));

		laddersByDistrict.values().stream().forEach(e -> {
			e.setBoss(e.getCrews().stream().max(Comparator.comparingInt(Crew::getTier)).get());
		});

		laddersByDistrict.values().forEach(e -> {
			Crew boss = e.getBoss();
			e.getCrews().forEach(crew -> {
				if (Util.unless(crew.equals(boss)) && Util.unless(CrewShip.exists(crew, boss))) { new CrewShip(Util.nextUUID(), 0, boss, crew); }
			});
		});
	}

	/* */
	public static Stream<Ladder> getLadders() { return laddersByDistrict.values().stream(); }
}

/* */
/* LOCALE */
/* */
class Locale {
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* */
	public static final List<String> COMMON_BUILDINGS = Collections.synchronizedList(new ArrayList<String>());
	public static final List<String> UNCOMMON_BUILDINGS = Collections.synchronizedList(new ArrayList<String>());
	public static final List<Locale> DISTRICTS = Collections.synchronizedList(new ArrayList<Locale>());

	/* */
	unique UUID id;
	name;

	/* */
	lazy int wealth; lazy int security; lazy int crime; lazy int occult;
	boolean isDistrict = false; boolean isNeighborhood = false;
	boolean isLair = false; boolean isHuntingGround = false; boolean isTurf = false;
	lazy Zoning zoning;

	key { id }

	0..1 parent -- * Locale children;

	boolean hasZoning = { zoning != null }

	/* */
	public static Stream<Locale> getLocales() { return localesById.values().stream(); }
	public static Stream<Locale> getDistricts() { return getLocales().filter(Locale::getIsDistrict); }
	public static Stream<Locale> getPlaces() { return getLocales().filter(Locale::hasParent); }
	public static Locale getLocaleByName(String name) {
		return getLocales().filter(l -> l.getName().matches(name)).findFirst().get();
	}

	/* */
	public static Stream<Ladder> getLadders() { return Ladder.getLadders(); }

	/* */
	public static synchronized String nextCommonBuilding() { String l = COMMON_BUILDINGS.remove(0); COMMON_BUILDINGS.add(l); return l; }
	public static synchronized String nextUncommonBuilding() { String l = UNCOMMON_BUILDINGS.remove(0); UNCOMMON_BUILDINGS.add(l); return l; }
	public static synchronized Locale nextDistrict() { Locale l = DISTRICTS.remove(0); DISTRICTS.add(l); return l; }
}

/* */
/* PLAYBOOK */
/* */
class Playbook {
	/* playbooks */
	const CUTTER = "cutter"; const HOUND = "hound"; const LEECH = "leech"; const LURK = "lurk"; const SLIDE = "slide"; const SPIDER = "spider"; const WHISPER = "whisper";
	
	/* */
	name = CUTTER;
}

/* */
/* ZONING */
/* */
class Zoning {
	/* work, play, movement, waiting, rest */
	const PURPOSE = "purpose"; const RULESPACE = "rulespace"; const PROFESSIONAL = "professional"; const PERSONAL = "personal";

	/* */
	type;

	/* instance */
	boolean isPublic = { type.matches(PURPOSE) || type.matches(RULESPACE) }
	boolean isPrivate = { type.matches(PROFESSIONAL) || type.matches(PERSONAL) }
}
