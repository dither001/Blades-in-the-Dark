
namespace com.blades.main;

/* */
/* CREW */
/* */
class Crew {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	depend com.blades.util.Util;

	/* */
	const AMBITIOUS = "ambitious"; // TODO
	/* */
	const ASSASSINS = "assassins"; const BRAVOS = "bravos"; const CULTISTS = "cultists"; const HAWKERS = "hawkers"; const SHADOWS = "shadows"; const SMUGGLERS = "smugglers";

	/* */
	unique UUID id;
	name; type;
	String[] reputation;
	favoredOp;
	lazy Score score;
	
	1 crew <@>- * Rogue rogues;
	0..1 crew <@>- * Locale turf;

	int rep = 0; int tier; int heat = 0; int wanted = 0; int coin;
	boolean hold;

	key { id }

	/* derived attributes */	
	boolean atWar = { CrewShip.atWar(this) }
	boolean lookingForWork = { Util.unless(turf.stream().anyMatch(Locale::getIsNeighborhood)) && Util.unless(score) }

	/** Primary means for determining crew's hold.
	* @return boolean modified by whether crew is at war. */
	boolean currentHold = { getAtWar() ? hold ? false : hold : hold }

	/** Primary means for determining crew's tier. 
	* @return int modified by whether crew is at war and has strong/weak hold. */
	int currentRep = { getAtWar() ? hold ? rep : rep - 1 : rep }
	
	/* */
	public static void initialize() {
		setupLairs();
		setupHuntingGrounds();
	}
	
	private static void setupLairs() {
		getCrews().filter(c -> Util.unless(c.hasLair())).forEach(c -> {
			Locale l = new Locale(Util.nextUUID(), Locale.nextCommonBuilding());
			l.setZoning(new Zoning(Zoning.PURPOSE));
			l.setCrew(c);
			l.setIsLair(true);
		});
	}
	
	private static void setupHuntingGrounds() {
		getCrews().filter(c -> Util.unless(c.hasHuntingGround())).forEach(c -> {
			Locale l = new Locale(Util.nextUUID(), Locale.nextCommonBuilding());
			l.setZoning(new Zoning(Zoning.PURPOSE));
			l.setCrew(c);
			l.setIsHuntingGround(true);
		});
	}
	
	/* instance */
	public boolean hasReputation(String rep) { return Util.ensure(indexOfReputation(rep)); }
	public Stream<Rogue> getRoster() { return rogues.stream(); }
	public Stream<Rogue> getAvailableRogues() { return rogues.stream().filter(Predicate.not(Rogue::getTapped)); }
	public int turfCount() { return (int) getTurf().stream().filter(Locale::getIsTurf).count(); }
	public Locale getLair() {  return getTurf().stream().filter(Locale::getIsLair).findFirst().orElse(null);  }
	public boolean hasLair() { return turf.stream().anyMatch(Locale::getIsLair); }
	public boolean hasHuntingGround() { return turf.stream().anyMatch(Locale::getIsHuntingGround); }
	public boolean hasScore() { return Util.ensure(score); }
	public void next() { if (Util.ensure(score)) { score.next(this); } }
	
	public void lookForWork() {
		Opportunity opp = Opportunity.next(this);
		if (Util.ensure(opp)) {
			System.out.println(name + " found work");
			Objective obj = objectify(opp);
			Activity activity = activity(obj);
			Plan plan = plan(activity);
			this.score = new Score(Util.nextUUID(), plan, opp);
		}
	}

	/* operational tasks */
	private Objective objectify(Opportunity opp) { return new Objective(opp); }
	
	private Activity activity(Objective obj) {
		Crew target = obj.getTarget();
		List<Obstacle> obs = assess(obj);

		Activity activity = new Activity(obj);
		CrewShip.getShips(target).map(ship -> ship.getOther(target)).forEach(activity::addInterestedParty);
		obs.forEach(activity::addRule);
		selectTools(obs).forEach(activity::addTool);
		selectRoles(obs).forEach(activity::addRole);
		selectTeam(activity).forEach(activity::addTeam);

		return activity;
	}
	
	private Plan plan(Activity activity) { return new Plan(this, activity); }

	private List<Obstacle> assess(Objective obj) {
		List<Obstacle> list = new ArrayList<Obstacle>();
		list.add(obj.getSituation().getObstacle());
		return list;
	}
	private List<Item> selectTools(List<Obstacle> obs) { return List.of(); }
	private List<Playbook> selectRoles(List<Obstacle> obs) { return List.of(); }
	private List<Rogue> selectTeam(Activity activity) { return List.copyOf(rogues); }
	
	/* static */
	public static Crew getCrewByName(String name) {
		return getCrews().filter(s -> s.getName().equalsIgnoreCase(name)).findFirst().get();
	}
	
	public static Crew getCrewByReputation(String rep) { return getCrews().filter(Crew::hasReputation).findFirst().get(); }

	public static Crew newFaction(UUID aId, String aName, int aTier, boolean aHold) {
		return new Crew(aId, aName, null, null, aTier, 0, aHold);
	}

	/* */
	public static Stream<Crew> getCrews() { return crewsById.values().stream(); };
	public static Stream<Crew> getCrewsLookingForWork() { return getCrews().filter(Crew::getLookingForWork); }
	public static Stream<Crew> getCrewsWithScores() { return getCrews().filter(Crew::hasScore); }
	public static void update() {  /* TODO */ getCrewsLookingForWork().forEach(Crew::lookForWork); }
}

/* */
/* CREWSHIP */
/* */
class CrewShip {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	/* */
	const Predicate<CrewShip> ALLIES = allies();
	const Predicate<CrewShip> ENEMIES = enemies();
	const Predicate<CrewShip> RIVALS = rivals();
	const Predicate<CrewShip> AT_WAR = at_war();

	/* */
	/* */
	unique UUID id;
	* <@>- 2 Crew crews;
	int value;

	key { id }
	
	/* derived attribute */
	String shipname = { String.format("%s + %s", getCrew(0).getName(), getCrew(1).getName()) }
	
	/* */
	boolean contains(Crew c) { return c.equals(crews.get(0)) || c.equals(crews.get(1)); }
	Crew getOther(Crew c) { return c.equals(crews.get(0)) ? crews.get(1) : c.equals(crews.get(1)) ? crews.get(0) : null; }

	/* */
	public static Stream<CrewShip> getShips() { return crewshipsById.values().stream(); }
	public static Stream<CrewShip> getShips(Crew crew) { return getShips().filter(c -> c.contains(crew)); }
	public static boolean atWar(Crew crew) { return getShips(crew).anyMatch(AT_WAR); }

	/* */
	private static Predicate<CrewShip> allies() { return ship -> { return ship.getValue() > 1; }; }
	private static Predicate<CrewShip> enemies() { return ship -> { return ship.getValue() < -1; }; }
	private static Predicate<CrewShip> rivals() { return ship -> { return ship.getValue() > -2 && ship.getValue() < 2; }; }
	private static Predicate<CrewShip> at_war() { return ship -> { return ship.getValue() < -2; }; }
}
