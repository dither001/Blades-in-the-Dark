
namespace com.blades.main;

/* */
/* CREW */
/* */
class Crew {
	depend java.util.concurrent.ArrayBlockingQueue;
	depend java.util.concurrent.BlockingQueue;
	depend java.util.function.Predicate;
	depend java.util.stream.Collectors;
	depend java.util.stream.Stream;

	depend com.blades.util.Util;

	/* */
	const int MAX_HEAT = 9;

	/* */
	unique UUID id;
	name;
	int rep = 0; int tier; int heat = 0; int wanted = 0; int coin;
	boolean hold;

	lazy Score score;

	0..1 -> 0..* Aspect; 
	0..1 patron -- 0..* Crew vassals;
	1 crew <@>- * Rogue rogues;
	0..1 crew <@>- * Locale turf;

	key { id }

	/* derived attributes */
	boolean isBoss = { isLocalBoss() && Util.unless(hasPatron()) }
	boolean hasBoss = { hasPatron() || Util.unless(getIsBoss()) || Util.unless(isLocalBoss()) }

	boolean atWar = { CrewShip.atWar(this) }
	boolean lookingForWork = { Util.unless(turf.stream().anyMatch(Locale::getIsNeighborhood)) && Util.unless(score) }

	/** Primary means for determining crew's hold.
	* @return boolean modified by whether crew is at war. */
	boolean currentHold = { getAtWar() ? hold ? false : hold : hold }

	/** Primary means for determining crew's tier. 
	* @return int modified by whether crew is at war and has strong/weak hold. */
	int currentRep = { getAtWar() ? hold ? rep : rep - 1 : rep }
	
	/* aspect orientation */
	after setHeat {
		if (heat >= MAX_HEAT) { int delta = heat / MAX_HEAT; setWanted(getWanted() + delta); heat -= delta; } 
	}
	
	/* */
	public static void initialize() {
		setupReputation();
		setupLairs();
		setupHuntingGrounds();
		setupUpgrades();
	}

	private static void setupReputation() {
		final BlockingQueue<Aspect> queue = new ArrayBlockingQueue<Aspect>(17, true, Aspect.getReputations());
		getCrews().forEach(e -> { Aspect aspect = queue.poll(); e.addAspect(aspect); queue.add(aspect); });
	}
	
	private static void setupUpgrades() {
		final BlockingQueue<Aspect> queue = new ArrayBlockingQueue<Aspect>(17, true, Aspect.getReputations());
		getCrews().forEach(e -> { Aspect aspect = queue.poll(); e.addAspect(aspect); queue.add(aspect); });
	}

	private static void setupLairs() {
		getCrews().filter(c -> Util.unless(c.hasLair())).forEach(c -> {
			Locale l = new Locale(Util.nextUUID(), Locale.nextCommonBuilding());
			l.setZoning(new Zoning(Zoning.PURPOSE));
			l.setCrew(c);
			l.setIsLair(true);
			l.setParent(Locale.nextDistrict());
		});
	}
	
	private static void setupHuntingGrounds() {
		getCrews().filter(c -> Util.unless(c.hasHuntingGround())).forEach(c -> {
			Locale l = new Locale(Util.nextUUID(), Locale.nextCommonBuilding());
			l.setZoning(new Zoning(Zoning.PURPOSE));
			l.setCrew(c);
			l.setIsHuntingGround(true);
			l.setParent(Locale.nextDistrict());
		});
	}
	
	/* instance */
	private Crew getLocalBoss() { return Util.ensure(hasLadder())? getLadder().getBoss(): null; }
	private boolean isLocalBoss() { return Util.ensure(getLocalBoss()) ? getLocalBoss().equals(this): false; }
	
	public Stream<Rogue> getRoster() { return rogues.stream(); }
	public Stream<Rogue> getAvailableRogues() { return rogues.stream().filter(Predicate.not(Rogue::getTapped)); }
	public int turfCount() { return (int) getTurf().stream().filter(Locale::getIsTurf).count(); }
	public Locale getLair() {  return getTurf().stream().filter(Locale::getIsLair).findFirst().orElse(null);  }
	public boolean hasLair() { return turf.stream().anyMatch(Locale::getIsLair); }
	public boolean hasHuntingGround() { return turf.stream().anyMatch(Locale::getIsHuntingGround); }
	public List<Locale> getHuntingGround() { return getTurf().stream().filter(Locale::getIsHuntingGround).collect(Collectors.toList()); }
	public boolean hasScore() { return Util.ensure(score); }
	
	void lookForWork() {
		Opportunity opp = Opportunity.next(this);
		if (Util.ensure(opp)) {
			/* System.out.println(name + " found work"); */
			int potentialRep = 2 - (getTier() - opp.getTarget().getTier());

			Plan plan = plan(activity(objectify(opp)), Approach.DECEPTION, null);
			Score newScore = new Score(Util.nextUUID(), opp, plan);
			newScore.setCrew(this);
			setScore(newScore);
		}
	}
	
	void payoff(Score score) {
		int coin = score.getCoin();
		int team = score.getTeam().size();

		/* */
		Crew boss = getHasBoss()? getLadder().getBoss() : null;
		int tithe = Util.ensure(boss) ? getTier() + 1 : 0;
		boolean canTithe = Util.ensure(boss) && (coin - tithe) / team > 0 ? true : false;

		if (coin > 0 && team > 0) {
			tithe = canTithe? tithe : 0;
			int share = (coin - tithe) / team;
			int crewshare = (coin - tithe) - (share * team);

			if (share > 0) {
				score.getTeam().forEach(r -> r.setCoin(r.getCoin() + share));
				setCoin(getCoin() + crewshare);
			}
		
			if (tithe > 0) { boss.setCoin(boss.getCoin() + tithe); }
			else if (Util.ensure(boss)) {
				CrewShip bossShip = getCrewShips().stream().filter(e -> e.contains(boss)).findFirst().get();
				bossShip.setValue(bossShip.getValue() - 1);
			}
		}
	}

	/* operational tasks */
	private Objective objectify(Opportunity opp) { return new Objective(opp); }
	
	private Activity activity(Objective obj) {
		Crew target = obj.getTarget();
		List<Aspect> obs = assess(obj);

		Activity activity = new Activity(obj);
		CrewShip.getShips(target).limit(3).forEach(activity::addInterestedParty);
		obs.forEach(activity::addRule);
		selectTools(obs).forEach(activity::addTool);
		selectRoles(obs).forEach(activity::addRole);
		selectTeam(activity).forEach(activity::addTeam);

		return activity;
	}
	
	private Plan plan(Activity activity, String approach, Situation detail) { return new Plan(activity, approach, detail); }

	private List<Aspect> assess(Objective obj) {
		List<Aspect> list = new ArrayList<Aspect>();
		list.add(obj.getSituation().getAspect());
		return list;
	}

	private List<Item> selectTools(List<Aspect> obs) { return List.of(); }
	private List<Playbook> selectRoles(List<Aspect> obs) { return List.of(); }
	private List<Rogue> selectTeam(Activity activity) { return List.copyOf(rogues); }
	
	/* static */
	public static Crew getCrewByName(String name) {
		return getCrews().filter(s -> s.getName().equalsIgnoreCase(name)).findFirst().get();
	}
	
	public static Crew newFaction(UUID aId, String aName, int aTier, boolean aHold) {
		return new Crew(aId, aName, aTier, 0, aHold);
	}

	/* */
	public static Stream<Crew> getCrews() { return crewsById.values().stream(); };
	public static Stream<Crew> getCrewsLookingForWork() { return getCrews().filter(Crew::getLookingForWork); }
	public static Stream<Crew> getCrewsWithScores() { return getCrews().filter(Crew::hasScore); }
	public static void update() {  /* TODO */ getCrewsLookingForWork().forEach(Crew::lookForWork); }
}

/* */
/* CREWSHIP */
/* */
class CrewShip {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;

	/* */
	const Predicate<CrewShip> ALLIES = allies();
	const Predicate<CrewShip> ENEMIES = enemies();
	const Predicate<CrewShip> RIVALS = rivals();
	const Predicate<CrewShip> AT_WAR = at_war();

	/* */
	unique UUID id;
 	* -- 2 Crew crews;
	int value;
	[value >= -3 && value <= 3]
	
	before constructor { if (allCrews[0].equals(allCrews[1])) return; }
	
	key { id, crews }

	/* derived attribute */
	String shipname = { String.format("%s + %s", getCrew(0).getName(), getCrew(1).getName()) }

	/* */
	boolean contains(Crew c) { return c.equals(crews.get(0)) || c.equals(crews.get(1)); }
	Crew getOther(Crew c) { return c.equals(crews.get(0)) ? crews.get(1) : c.equals(crews.get(1)) ? crews.get(0) : null; }
	boolean hasStatus(Predicate<CrewShip> pred) { return pred.test(this); }

	/* */
	public static boolean exists(Crew c1, Crew c2) { return getShips(c1).anyMatch(ship -> ship.contains(c2)); }
	public static Stream<CrewShip> getShips() { return crewshipsById.values().stream(); }
	public static Stream<CrewShip> getShips(Crew crew) { return getShips().filter(c -> c.contains(crew)); }
	public static CrewShip getShip(Crew c1, Crew c2) { return getShips(c1).filter(ship -> ship.contains(c2)).findFirst().orElse(null); }
	public static boolean atWar(Crew crew) { return getShips(crew).anyMatch(AT_WAR); }

	/* */
	private static Predicate<CrewShip> allies() { return ship -> { return ship.getValue() > 1; }; }
	private static Predicate<CrewShip> enemies() { return ship -> { return ship.getValue() < -1; }; }
	private static Predicate<CrewShip> rivals() { return ship -> { return ship.getValue() > -2 && ship.getValue() < 2; }; }
	private static Predicate<CrewShip> at_war() { return ship -> { return ship.getValue() < -2; }; }
}
