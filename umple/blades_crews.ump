
namespace com.blades.main;

/* */
/* CREW */
/* */
class Crew {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	depend com.blades.util.Util;

	/* */
	const AMBITIOUS = "ambitious"; // TODO
	/* */
	const ASSASSINS = "assassins"; const BRAVOS = "bravos"; const CULTISTS = "cultists"; const HAWKERS = "hawkers"; const SHADOWS = "shadows"; const SMUGGLERS = "smugglers";

	/* */
	unique UUID id;
	name; type;
	String[] reputation;
	favoredOp;
	lazy internal Score score;
	
	1 crew <@>- * Rogue rogues;
	0..1 crew <@>- * Locale turf;

	int rep = 0; int tier; int heat = 0; int wanted = 0; int coin;
	boolean hold;

	key { id }

	/* derived attributes */	
	boolean atWar = { CrewShip.atWar(this) }
	boolean lookingForWork = { Util.unless(turf.stream().anyMatch(Locale::isNeighborhood)) && Util.unless(score) }

	/** Primary means for determining crew's hold.
	* @return boolean modified by whether crew is at war. */
	boolean currentHold = { getAtWar() ? hold ? false : hold : hold }

	/** Primary means for determining crew's tier. 
	* @return int modified by whether crew is at war and has strong/weak hold. */
	int currentRep = { getAtWar() ? hold ? rep : rep - 1 : rep }
	
	/* instance */
	public Stream<Rogue> getRoster() { return rogues.stream(); }
	public Stream<Rogue> getAvailableRogues() { return rogues.stream().filter(Predicate.not(Rogue::getTapped)); }
	public int turfCount() { return (int) getTurf().stream().filter(Locale::getIsTurf).count(); }
	public Locale getLair() {  return getTurf().stream().filter(Locale::getIsLair).findFirst().orElse(null);  }
	public boolean hasLair() { return turf.stream().anyMatch(Locale::getIsLair); }
	
	public void lookForWork() {
		Opportunity opp = Opportunity.getOpportunities(this).findFirst().orElse(null);
		if (Util.ensure(opp)) {
			Objective obj = objectify(opp);
			Plan plan = makePlan(obj);
			this.score = new Score(Util.nextUUID(), plan, opp);
		}
	}

	/* operational tasks */
	private Objective objectify(Opportunity opp) { return new Objective(opp); }

	private List<Obstacle> assess(Objective obj) {
		List<Obstacle> list = new ArrayList<Obstacle>();
		list.add(obj.getSituation().getObstacle());
		return list;
	}
	private List<Item> selectTools(List<Obstacle> obs) { return List.of(); }
	private List<Playbook> selectRoles(List<Obstacle> obs) { return List.of(); }
	private List<Rogue> selectTeam(Activity activity) { return List.copyOf(rogues); }

	private Plan makePlan(Objective obj) {
		Crew target = obj.getTarget();
		List<Obstacle> obs = assess(obj);

		Activity activity = new Activity(obj);
		CrewShip.getShips(target).map(ship -> ship.getOther(target)).forEach(activity::addInterestedParty);
		obs.forEach(activity::addRule);
		selectTools(obs).forEach(activity::addTool);
		selectRoles(obs).forEach(activity::addRole);
		selectTeam(activity).forEach(activity::addTeam);

		return new Plan(this, activity);
	}
	
	/* static */
	public static Crew getCrewByName(String name) {
		return getCrews().filter(s -> s.getName().equalsIgnoreCase(name)).findFirst().get();
	}
	
	public static Crew getCrewByReputation(String rep) {
		return getCrews().filter(s -> s.indexOfReputation(rep) > -1).findFirst().get();
	}

	public static Crew newFaction(UUID aId, String aName, int aTier, boolean aHold) {
		return new Crew(aId, aName, null, null, aTier, 0, aHold);
	}

	/* */
	public static Stream<Crew> getCrews() { return crewsById.values().stream(); };
	public static Stream<Crew> getCrewsLookingForWork() { return getCrews().filter(Crew::getLookingForWork); }
	public static void update() {
		/* TODO */
		getCrewsLookingForWork().forEach(Crew::lookForWork);
	}
}

/* */
/* CREWSHIP */
/* */
class CrewShip {
	depend java.util.function.Predicate;
	depend java.util.stream.Stream;
	
	/* */
	const Predicate<CrewShip> ALLIES = allies();
	const Predicate<CrewShip> ENEMIES = enemies();
	const Predicate<CrewShip> RIVALS = rivals();
	const Predicate<CrewShip> AT_WAR = at_war();

	/* */
	/* */
	unique UUID id;
	* <@>- 2 Crew crews;
	int value;

	key { id }
	
	/* derived attribute */
	String shipname = { String.format("%s + %s", getCrew(0).getName(), getCrew(1).getName()) }
	
	/* */
	boolean contains(Crew c) { return c.equals(crews.get(0)) || c.equals(crews.get(1)); }
	Crew getOther(Crew c) { return c.equals(crews.get(0)) ? crews.get(1) : c.equals(crews.get(1)) ? crews.get(0) : null; }

	/* */
	public static Stream<CrewShip> getShips() { return crewshipsById.values().stream(); }
	public static Stream<CrewShip> getShips(Crew crew) { return getShips().filter(c -> c.contains(crew)); }
	public static boolean atWar(Crew crew) { return getShips(crew).anyMatch(AT_WAR); }

	/* */
	private static Predicate<CrewShip> allies() { return ship -> { return ship.getValue() > 1; }; }
	private static Predicate<CrewShip> enemies() { return ship -> { return ship.getValue() < -1; }; }
	private static Predicate<CrewShip> rivals() { return ship -> { return ship.getValue() > -2 && ship.getValue() < 2; }; }
	private static Predicate<CrewShip> at_war() { return ship -> { return ship.getValue() < -2; }; }
}
